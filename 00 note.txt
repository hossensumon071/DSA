
Algorithms
     - an alogorithms is a set of instructions or steps for solving a problems.
     Why you shuold learn algotrithm
      01. critical thinking and abstruction
       02. problem solving 
       03. computer science
       04. career advancement
       05. understing new techs
  
     time complexity, space complexity
       - time complexity is a way to analyze the total time or performance of an algorithm
       - space complexity is a way to analyze the total space or memory need for an algorithm
  
    asymptotic notation
       - je mathmatical notation er shahajje time and space express kora hoi take asymptotic notaition bola hoye thake   
         - describe the time complexity or space complexity 
         - asymptotic notation shahajje time and space compelxity ke bhujano hoi 
         - asymptotic notation 3 prokar 
         - big O notation, big omega notation and big theta notation 
  
            big O notation
              - [big O notaition] er shahajje amra time and space complexity measure korbo ekta algorithom er jonno 

                O(1) --> constant/base time or space complexity
                         - apnar jokon ekta program ba algorithm thakbe sei programm input jai e nik na kno output ta delivery korar time e 1 fraction of time lagbe ba 1 fraction of space lagbe 
                O(log n) --> logarithmic
                             - apnar je programm thakbe prottekbar sei programm ke input dile se sei ta ke ordek kore felbe input size ta ordek size kore felbe 
                O(n) --> linear
                          - ekhane input size barle time barbe input size komle time kombe 

                uporer ei 3 ta hocche shob thekey best . 3 tar bitor shob theke best hocche O(1)

                0(n log n) ---> linear logarithmic
                0(n^c) --> polynomorial time / c = power 
                0(c^n) --> exponentital time 
                            - ekbar system run koraben shokol input diye oi input diye just system take double kore dibe 
                0(n!)  --> factorial 
                           - factorial onk baje ekta time compelxity





9) Linear search 
   [1,5,14,7,9], 7 --> 3
   [1,5,14,7,9], 6 --> -1

   function linearSearch(arr, target) {
    for(let i = 0; i < arr.length; i++) {
      if(arr[i] === target) {
        return i;
      }
    }

    return -1;
   }

   console.log(linearSearch([1,5,14,7,9],7)) // 3
   console.log(linearSearch([1,5,14,7,9],6)) // -1

   o(n) --> linear



   10) Binary Search

   function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
      let mid = Math.floor((left + right) / 2);

      if(target === arr[mid]) {
        return mid;
      } else if (target > arr[mid]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    return -1;
   }

   console.log(binarySearch([2,4,6,8,11], 4))
   console.log(binarySearch([2,4,6,8,11], 4))

   - loop thaka shotte o jokon increases size decrease by half tokon ei o(log n)  complexity hobe 
   - o(log n)
   - o(1)



   11) recursive Binary search 
       
       function binarySearch(arr, target, left, right){
         if(left > right) return -1;

         let mid = Math.floor((left + right) / 2);

         if(target == arr[mid]) return mid;
         if(target > arr[mid]) {
          return binarySearch(arr, target, mid + 1, right);
         } else {
          return binarySearch(arr, target, left, mid -1);
         }
       }

       console.log([1,2,3,4,5,6], 5, 0, 5)

       --> time compelxity
             o(log n) logarithmic
             less efficient for large inputs


  12) Shorting algorithom
         Bubble short 
             [3,4,2,0,5,-1,6,1]
             [-1, 0, 1, 2, 3,, 4, 5, 6]

          function bubbleSort(arr) {
            for(left i = 0; i < arr.length: i++) {
              for(let j = 0; j < arr.length; j++) {
                if(arr[j] > arr(j + 1)){
                  let temp = arr[j] 
                  arr[j] = arr[j+1]
                  arr[j+1] = temp;
                }
              }
            }

            return arr;  
          } 

          console.log(bubbleSort([3,4,2,0,5,-1,6,1]))  

          o(n*2) --> quadratic time compelxity

          jokon ekta loop er bitor r ekta loop thake tokon n^2 loop hobe jodi 3 ta loop thake thaole n^3 loop tokon qubic time 

          bubble short effiecent kichu na 


  13) Incertion Short
         
         function insertionsSort(arr) {
            for(lt i = 1; i < arr.length; i++) {
              let currentEl = arr[i]

              // swap 
              let j = i -1
              for(; j>= 0 && arr[j] > currentEl; j--){
                arr[j+1] = arr[j]
              }

              arr[j + 1] = currentEl;
            }

            return arr;
         }
         cosole.log([3,4,0,5-1,2,6])

         function insertionsSort(arr) {
            for (let i = 1; i < arr.length; i++){
              const currentEl = arr[i]

              let j = i - 1

              while(j>=0 && arr[j] > current) {
                arr[j+1] = arr[j];
                j--;
              }
              arr[j+1] = current;
            }

            return arr;
         }
         cosole.log([3,4,0,5-1,2,6])

// o(n^2)



14) Quick-short 

      function quickSort (arr) {
        if (arr.length <= 1) {
          return arr;
        }

        const ppointerEl = arr[0];
        const left = [];
        const right = [];

        for(let i = 1; i < arr.length; i++) {
          if(arr[i] > pointerEl) {
            right.push(arr[i])
          } else {
            left.push(arr[i]);
          }
        }

        return [...quickSort(left), pointerEl, ...quickSort(right)];
      }

      console.log(quickSort([2,6,1,9,5,-1,0,11]));

      o(n*2)
      space o(n)

    
15) Merge Short 

       function mergerSort(arr) {
        if(arr.length < 2) {
          return arr;
        }

        let mid = Math.floor(arr.length / 2)
        let left = arr.slice(0, mid)
        let right = arr.slice(mid)

        return merge(mergerSort(left), mergerSort(right))
       }

       function merge(left, right) {
          const container = [];

          let li = 0;
          let ri = 0;

          while(li < left.length && ri < right.length) {
            if(left[li] < right[ri]) {
              contianer.push(left(li++))
            } else {
              container.push(right[ri++]);
            }
          }

          return container.concat(left.slice(li)).concat(right.slice(ri));
       }

       console.log(mergeSort([4, 0, 1, 9, -1, 3, 5, 2]));

// o(n log n) --> overall 