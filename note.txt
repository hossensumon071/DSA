
Algorithms
     - an alogorithms is a set of instructions or steps for solving a problems.
     Why you shuold learn algotrithm
      01. critical thinking and abstruction
       02. problem solving 
       03. computer science
       04. career advancement
       05. understing new techs
  
     time complexity, space complexity
       - time complexity is a way to analyze the total time or performance of an algorithm
       - space complexity is a way to analyze the total space or memory need for an algorithm
  
    asymptotic notation
         - describe the time complexity or space complexity 
         - asymptotic notation shahajje time and space compelxity ke bhujano hoi 
         - asymptotic notation 3 prokar 
         - big o notation, big omega notation and big theta notation 
  
            big o notation
              - [big o notaition] er shahajje amra time and space complexity measure korbo ekta algorithom er jonno 

                0(1) --> constant/base time or space complexity
                         - apnar jokon ekta program ba algorithm thakbe sei programm input jai e nik na kno output ta delivery korar time e 1 fraction of time lagbe ba 1 fraction of space lagbe 
                0(log n) --> logarithmic
                             - apnar je programm thakbe prottekbar sei programm ke input dile se sei ta ke ordek kore felbe input size ta ordek size kore felbe 
                0(n) --> linear
                          - ekhane input size barle time barbe input size komle time kombe 

                uporer ei 3 ta hocche shob thekey best 

                0(n log n) ---> linear logarithmic
                0(n^c) --> polynomorial time / c = power 
                0(c^n) --> exponentital time 
                0(n!)  --> factorial 
          

1) Given an array, find the largest el
      
      function largestEl(arr) {
        let largeEl = arr[0];

        for(let i = 1; i < arr.length; i++) {
          if(arr[i] > largeEl) {
            largeEl = arr[i]
          }
        }
        return largeEl
      }

      console.log(largestEl([2,34,5,55,6]))

      - aitar time compelxity hobe
         - el = 5, run = 5,
           el = 1000, run = 1000,
           el = n, run = n,
           0(n) --> linear 
           - ekhane dekar bishoy hocche elment joto ta run o hocche toto bar so ekhane time compelxity and spce complexity bere jacche 
      

2) Given an array, find the first element of this arr
    
    function findFirstEl(arr) {
      return arr.at(0)
    }

    console.log(findFirstEl([10, 20, 30]));

    el = 10, run = 1,
    el = 1000, run = 1,
    0(1) --> constant

    - ekhane code run hoiche only 1 bar jodi element 1000 o hoi tarporo element run hobe 1 bar e mane aita element er upore nirbor korche na 


3) fibonacchi 
       [0, 1,1,2,3,5,8,10,13,....]
       n = (n-1) + (n-2)

       function fibonacchi(n) {
          let fibo = [0, 1]

          for (let i =2; i < n; i++) {
            fibo[i] = fibo[i - 1] + fibo[i - 2];
          }

          return fibo;
       }

       console.log(fibonacchi(8))

       - ekhane for loop jodi ekta thake tahole automatically 0(n) dewa jai . erpor think korte hobe komche naki barche . ekhane n shonkok input er jonno n shonkok time lagbe 

       - 0(n) time compelxity hobe mane linear time compelxity 


4) factorial 
      5! = 5 * 4 * 3 * 2 * 1
      4! = 4 * 3 * 2 * 1
      n! = n * (n -1) * (n - 2) * .... * (n == 1)


      function factorial (n) {
        let fact = 1;

        for(let i = 1; i <= n; i++) {
          fact *= i;
        }

        return fact;
      }

      console.log(factorial(10))

        --> ekhane time compelxity 0(n) linear time compelxity


6) Prime Number 
      
      function isPrime(num) {
         if(num <= 1) {
          return false;
         }

         for(let i = 2; i < num; i++) {
          if(num % i === 0) {
            return false;
          }
         }

         return true;
      }

      console.log(isPrime(11))
      console.log(isPrime(10))

      --> this is lenear time compelxity


7) Power of Two
     
     function isPowerOfTwo(n) {
        if(n<= 0) return false;
        
        while(n%2 === 0) {
          n = n / 2
        }

        return n === 1;
     }

     console.log(isPowerOfTwo(16))
     console.log(isPowerOfTwo(18))
     console.log(isPowerOfTwo(8))
     console.log(isPowerOfTwo(64))

     --> ekhane time compelxity hobe 
            o(log n) logarithmic time compelxity
            and aitar performance onk valo linear er theke 


8) Recusrsive case 
        --> kno ekta function ke jodi oi function er bitor abr call kora hoi tahole oi function ke bola hoi recursive function 

    1) recursive fibonacchi
       - find the nth element from fibonacci series
            f(n) = f(n-1) + f(n-2)
            n <= 0 --> 0
            n === 1 --> 1

        function fibonacchi(n) {
          if(n <= 0) return 0;
          if(n === 1) return 1;

          return fibonacchi(n - 1) + fibonacchi (n - 2);
        }

        console.log(fibonacchi(5));

        --> aitar time compelxity hobe o(2^n) ja baje ekta time compelxity. tai Recusrsive way ta kintu shob programme er jonno suitable na . recursive way to fibonacchi kora ta tik na 
        --> o(c^n) --> exponentital time 


    2) recursive factorial
         
         3! = 3 * 2 * 1
         3! = 3 * 2!
         n! = n * (n - 1)
         n === 0 --> 1

         function fact (n) {
          if(n ===0 ) return 1;

          return n * fact(n - 1);
         }

         console.log(fact(5));

         --> o(n)

9) Linear search 
   [1,5,14,7,9], 7 --> 3
   [1,5,14,7,9], 6 --> -1

   function linearSearch(arr, target) {
    for(let i = 0; i < arr.length; i++) {
      if(arr[i] === target) {
        return i;
      }
    }

    return -1;
   }

   console.log(linearSearch([1,5,14,7,9],7)) // 3
   console.log(linearSearch([1,5,14,7,9],6)) // -1

   o(n) --> linear



   10) Binary Search

   function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
      let mid = Math.floor((left + right) / 2);

      if(target === arr[mid]) {
        return mid;
      } else if (target > arr[mid]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    return -1;
   }

   console.log(binarySearch([2,4,6,8,11], 4))
   console.log(binarySearch([2,4,6,8,11], 4))

   - loop thaka shotte o jokon increases size decrease by half tokon ei o(log n)  complexity hobe 
   - o(log n)
   - o(1)



   11) recursive Binary search 
       
       function binarySearch(arr, target, left, right){
         if(left > right) return -1;

         let mid = Math.floor((left + right) / 2);

         if(target == arr[mid]) return mid;
         if(target > arr[mid]) {
          return binarySearch(arr, target, mid + 1, right);
         } else {
          return binarySearch(arr, target, left, mid -1);
         }
       }

       console.log([1,2,3,4,5,6], 5, 0, 5)

       --> time compelxity
             o(log n) logarithmic
             less efficient for large inputs


  12) Shorting algorithom
         Bubble short 
             [3,4,2,0,5,-1,6,1]
             [-1, 0, 1, 2, 3,, 4, 5, 6]

          function bubbleSort(arr) {
            for(left i = 0; i < arr.length: i++) {
              for(let j = 0; j < arr.length; j++) {
                if(arr[j] > arr(j + 1)){
                  let temp = arr[j] 
                  arr[j] = arr[j+1]
                  arr[j+1] = temp;
                }
              }
            }

            return arr;  
          } 

          console.log(bubbleSort([3,4,2,0,5,-1,6,1]))  

          o(n*2) --> quadratic time compelxity

          jokon ekta loop er bitor r ekta loop thake tokon n^2 loop hobe jodi 3 ta loop thake thaole n^3 loop tokon qubic time 

          bubble short effiecent kichu na 


  13) Incertion Short
         
         function insertionsSort(arr) {
            for(lt i = 1; i < arr.length; i++) {
              let currentEl = arr[i]

              // swap 
              let j = i -1
              for(; j>= 0 && arr[j] > currentEl; j--){
                arr[j+1] = arr[j]
              }

              arr[j + 1] = currentEl;
            }

            return arr;
         }
         cosole.log([3,4,0,5-1,2,6])

         function insertionsSort(arr) {
            for (let i = 1; i < arr.length; i++){
              const currentEl = arr[i]

              let j = i - 1

              while(j>=0 && arr[j] > current) {
                arr[j+1] = arr[j];
                j--;
              }
              arr[j+1] = current;
            }

            return arr;
         }
         cosole.log([3,4,0,5-1,2,6])

// o(n^2)



14) Quick-short 

      function quickSort (arr) {
        if (arr.length <= 1) {
          return arr;
        }

        const ppointerEl = arr[0];
        const left = [];
        const right = [];

        for(let i = 1; i < arr.length; i++) {
          if(arr[i] > pointerEl) {
            right.push(arr[i])
          } else {
            left.push(arr[i]);
          }
        }

        return [...quickSort(left), pointerEl, ...quickSort(right)];
      }

      console.log(quickSort([2,6,1,9,5,-1,0,11]));

      o(n*2)
      space o(n)